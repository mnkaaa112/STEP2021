## 宿題1
行列計算プログラム(Matrix.java)
行列のサイズNと計算時間の関係を図1に示した。両対数グラフで比例関係が見られることから行列のサイズが増えると計算時間はべき関数的に増加すると言える。

## 宿題2
ハッシュテーブルではなく木構造が使われる理由
- 規模が大きくなっても無限に拡張できる
- 順序を持って格納できる

## 宿題3
完全なプログラムを実装することはできなかったが途中過程であるCache.javaの方針を以下に示す．

用意するデータ構造
```Java
int n; //キャッシュのサイズ
String[][] cache = new String[n][4]; 
//cache[url][contents][一つ前にキャッシュされたデータのハッシュ値][この次にキャッシュされたデータのハッシュ値]
//前後に格納されたデータの格納場所を保持しLinkedListのような働きをする
LinkedList<String>[][] database; //ハッシュ値が重複した際のデータ格納場所を保持するデータベース
int newest = 0; //一番古いデータのハッシュ値
int oldest = 0; //一番新しいデータのハッシュ値
```
access_page()の説明
```
urlのハッシュ値(key)を求める
キャッシュのkeyの場所に該当urlが格納されているか
No→
  ハッシュ値が重複したために別の場所に保存されているか(databaseを参照、ここはO(1)ではない)
    Yes→該当urlが格納されている場所のハッシュ値(newkey)を得てnewestに設定、cache[newkey]の前後を繋ぎなおす
    No→キャッシュには格納されていないので一番古いurlと入れ替える、newestをoldestに入れ替えて前後を繋ぎなおす
Yes→
  keyをnewestにして前後を繋ぎなおす
```
<検討した点>
- 一番古いデータと新しいデータのハッシュ値が等しいわけではないこと→databaseで格納するキャッシュの場所を保持

<懸念点>
- サイズが固定されたハッシュテーブルでハッシュ値が重複した場合の処理方法->計算量O(1)でない
- キャッシュにまだ空きがある、かつハッシュ値が重複した場合の処理について網羅していない
- 異なる型を同じ配列で扱うことができないため本質的には冗長な処理を含んでいる

